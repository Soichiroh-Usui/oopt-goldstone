diff --git a/sonic-xcvrd/xcvrd/xcvrd.py b/sonic-xcvrd/xcvrd/xcvrd.py
index da1766e..c5431b3 100644
--- a/sonic-xcvrd/xcvrd/xcvrd.py
+++ b/sonic-xcvrd/xcvrd/xcvrd.py
@@ -18,7 +18,7 @@ try:
     import datetime
     import subprocess
     import argparse
-
+ 
     from sonic_py_common import daemon_base, device_info, logger
     from sonic_py_common import multi_asic
     from swsscommon import swsscommon
@@ -47,7 +47,7 @@ MGMT_INIT_TIME_DELAY_SECS = 2
 # SFP insert event poll duration
 SFP_INSERT_EVENT_POLL_PERIOD_MSECS = 1000
 
-DOM_INFO_UPDATE_PERIOD_SECS = 60
+DOM_INFO_UPDATE_PERIOD_SECS = 1
 STATE_MACHINE_UPDATE_PERIOD_MSECS = 60000
 TIME_FOR_SFP_READY_SECS = 1
 
@@ -123,8 +123,8 @@ def _wrapper_get_presence(physical_port):
     if platform_chassis is not None:
         try:
             return platform_chassis.get_sfp(physical_port).get_presence()
-        except NotImplementedError:
-            pass
+        except (NotImplementedError, Exception):
+            return False
     return platform_sfputil.get_presence(physical_port)
 
 
@@ -132,35 +132,53 @@ def _wrapper_is_replaceable(physical_port):
     if platform_chassis is not None:
         try:
             return platform_chassis.get_sfp(physical_port).is_replaceable()
-        except NotImplementedError:
-            pass
+        except (NotImplementedError, Exception):
+            return False
     return False
 
 
 def _wrapper_get_transceiver_info(physical_port):
     if platform_chassis is not None:
         try:
-            return platform_chassis.get_sfp(physical_port).get_transceiver_info()
-        except NotImplementedError:
-            pass
+            sfp = platform_chassis.get_sfp(physical_port)
+            api = sfp.get_xcvr_api()
+            return api.get_transceiver_info()
+        except (NotImplementedError, Exception):
+            return None
     return platform_sfputil.get_transceiver_info_dict(physical_port)
 
 
 def _wrapper_get_transceiver_dom_info(physical_port):
     if platform_chassis is not None:
         try:
-            return platform_chassis.get_sfp(physical_port).get_transceiver_bulk_status()
-        except NotImplementedError:
-            pass
+            sfp = platform_chassis.get_sfp(physical_port)
+            api = sfp.get_xcvr_api()
+
+            dom_info_dict = api.get_transceiver_bulk_status()
+            if sfp.sfp_type == 'QSFP_DD':
+                # get module_state and dp[1-8]state
+                dom_info_dict['module_state'] = api.get_module_state()
+                dp_state_dict = api.get_datapath_state()
+                dom_info_dict.update(dp_state_dict)
+
+                # get active_appl_code[1-8]
+                for i in range(8):
+                    dom_info_dict['active_appl_code{}'.format(i+1)] = api.get_application(i)
+            return dom_info_dict
+        except (NotImplementedError, Exception):
+            return None
     return platform_sfputil.get_transceiver_dom_info_dict(physical_port)
 
 
 def _wrapper_get_transceiver_dom_threshold_info(physical_port):
     if platform_chassis is not None:
         try:
-            return platform_chassis.get_sfp(physical_port).get_transceiver_threshold_info()
-        except NotImplementedError:
-            pass
+            sfp = platform_chassis.get_sfp(physical_port)
+            api = sfp.get_xcvr_api()
+            return api.get_transceiver_threshold_info()
+        except (NotImplementedError, Exception):
+            return None
+
     return platform_sfputil.get_transceiver_dom_threshold_info_dict(physical_port)
 
 # Soak SFP insert event until management init completes
@@ -185,8 +203,8 @@ def _wrapper_get_transceiver_change_event(timeout):
             sfp_events = events.get('sfp')
             sfp_errors = events.get('sfp_error')
             return status, sfp_events, sfp_errors
-        except NotImplementedError:
-            pass
+        except (NotImplementedError, Exception):
+            return False, {}, None
     status, events = platform_sfputil.get_transceiver_change_event(timeout)
     return status, events, None
 
@@ -215,6 +233,7 @@ def _wrapper_get_sfp_error_description(physical_port):
 # Remove unnecessary unit from the raw data
 
 def beautify_dom_info_dict(dom_info_dict, physical_port):
+    NO_UNIT = ''
     dom_info_dict['temperature'] = strip_unit_and_beautify(dom_info_dict['temperature'], TEMP_UNIT)
     dom_info_dict['voltage'] = strip_unit_and_beautify(dom_info_dict['voltage'], VOLT_UNIT)
     dom_info_dict['rx1power'] = strip_unit_and_beautify(dom_info_dict['rx1power'], POWER_UNIT)
@@ -242,6 +261,40 @@ def beautify_dom_info_dict(dom_info_dict, physical_port):
         dom_info_dict['tx6power'] = strip_unit_and_beautify(dom_info_dict['tx6power'], POWER_UNIT)
         dom_info_dict['tx7power'] = strip_unit_and_beautify(dom_info_dict['tx7power'], POWER_UNIT)
         dom_info_dict['tx8power'] = strip_unit_and_beautify(dom_info_dict['tx8power'], POWER_UNIT)
+    if 'module_state' in dom_info_dict:
+        dom_info_dict['module_state'] = strip_unit_and_beautify(dom_info_dict['module_state'], NO_UNIT)
+    if 'DP1State' in dom_info_dict:
+        dom_info_dict['DP1State'] = strip_unit_and_beautify(dom_info_dict['DP1State'], NO_UNIT)
+        dom_info_dict['DP2State'] = strip_unit_and_beautify(dom_info_dict['DP2State'], NO_UNIT)
+        dom_info_dict['DP3State'] = strip_unit_and_beautify(dom_info_dict['DP3State'], NO_UNIT)
+        dom_info_dict['DP4State'] = strip_unit_and_beautify(dom_info_dict['DP4State'], NO_UNIT)
+        dom_info_dict['DP5State'] = strip_unit_and_beautify(dom_info_dict['DP5State'], NO_UNIT)
+        dom_info_dict['DP6State'] = strip_unit_and_beautify(dom_info_dict['DP6State'], NO_UNIT)
+        dom_info_dict['DP7State'] = strip_unit_and_beautify(dom_info_dict['DP7State'], NO_UNIT)
+        dom_info_dict['DP8State'] = strip_unit_and_beautify(dom_info_dict['DP8State'], NO_UNIT)
+    if 'active_appl_code1' in dom_info_dict:
+        dom_info_dict['active_appl_code1'] = strip_unit_and_beautify(dom_info_dict['active_appl_code1'], NO_UNIT)
+        dom_info_dict['active_appl_code2'] = strip_unit_and_beautify(dom_info_dict['active_appl_code2'], NO_UNIT)
+        dom_info_dict['active_appl_code3'] = strip_unit_and_beautify(dom_info_dict['active_appl_code3'], NO_UNIT)
+        dom_info_dict['active_appl_code4'] = strip_unit_and_beautify(dom_info_dict['active_appl_code4'], NO_UNIT)
+        dom_info_dict['active_appl_code5'] = strip_unit_and_beautify(dom_info_dict['active_appl_code5'], NO_UNIT)
+        dom_info_dict['active_appl_code6'] = strip_unit_and_beautify(dom_info_dict['active_appl_code6'], NO_UNIT)
+        dom_info_dict['active_appl_code7'] = strip_unit_and_beautify(dom_info_dict['active_appl_code7'], NO_UNIT)
+        dom_info_dict['active_appl_code8'] = strip_unit_and_beautify(dom_info_dict['active_appl_code8'], NO_UNIT)
+
+    # Add new key and value
+    if 'rx_los' in dom_info_dict:
+        dom_info_dict['rx_los'] = strip_unit_and_beautify(dom_info_dict['rx_los'], NO_UNIT)
+    if 'prefec_ber' in dom_info_dict:
+        dom_info_dict['prefec_ber'] = strip_unit_and_beautify(dom_info_dict['prefec_ber'], NO_UNIT)
+    if 'laser_config_freq' in dom_info_dict:
+        dom_info_dict['laser_config_freq'] = strip_unit_and_beautify(int(dom_info_dict['laser_config_freq'] * 1000), NO_UNIT)
+    if 'laser_curr_freq' in dom_info_dict:
+        dom_info_dict['laser_curr_freq'] = strip_unit_and_beautify(int(dom_info_dict['laser_curr_freq'] * 1000), NO_UNIT)
+    if 'tx_config_power' in dom_info_dict:
+        dom_info_dict['tx_config_power'] = strip_unit_and_beautify(dom_info_dict['tx_config_power'], NO_UNIT)
+    if 'tx_curr_power' in dom_info_dict:
+        dom_info_dict['tx_curr_power'] = strip_unit_and_beautify(dom_info_dict['tx_curr_power'], NO_UNIT)
 
 
 def beautify_dom_threshold_info_dict(dom_info_dict):
@@ -509,32 +562,66 @@ def post_port_dom_info_to_db(logical_port_name, port_mapping, table, stop_event=
                 if 'rx5power' in dom_info_dict:
                     fvs = swsscommon.FieldValuePairs(
                         [('temperature', dom_info_dict['temperature']),
-                         ('voltage', dom_info_dict['voltage']),
-                         ('rx1power', dom_info_dict['rx1power']),
-                         ('rx2power', dom_info_dict['rx2power']),
-                         ('rx3power', dom_info_dict['rx3power']),
-                         ('rx4power', dom_info_dict['rx4power']),
-                         ('rx5power', dom_info_dict['rx5power']),
-                         ('rx6power', dom_info_dict['rx6power']),
-                         ('rx7power', dom_info_dict['rx7power']),
-                         ('rx8power', dom_info_dict['rx8power']),
-                         ('tx1bias', dom_info_dict['tx1bias']),
-                         ('tx2bias', dom_info_dict['tx2bias']),
-                         ('tx3bias', dom_info_dict['tx3bias']),
-                         ('tx4bias', dom_info_dict['tx4bias']),
-                         ('tx5bias', dom_info_dict['tx5bias']),
-                         ('tx6bias', dom_info_dict['tx6bias']),
-                         ('tx7bias', dom_info_dict['tx7bias']),
-                         ('tx8bias', dom_info_dict['tx8bias']),
-                         ('tx1power', dom_info_dict['tx1power']),
-                         ('tx2power', dom_info_dict['tx2power']),
-                         ('tx3power', dom_info_dict['tx3power']),
-                         ('tx4power', dom_info_dict['tx4power']),
-                         ('tx5power', dom_info_dict['tx5power']),
-                         ('tx6power', dom_info_dict['tx6power']),
-                         ('tx7power', dom_info_dict['tx7power']),
-                         ('tx8power', dom_info_dict['tx8power'])
-                         ])
+                            ('voltage', dom_info_dict['voltage']),
+                            ('rx1power', dom_info_dict['rx1power']),
+                            ('rx2power', dom_info_dict['rx2power']),
+                            ('rx3power', dom_info_dict['rx3power']),
+                            ('rx4power', dom_info_dict['rx4power']),
+                            ('rx5power', dom_info_dict['rx5power']),
+                            ('rx6power', dom_info_dict['rx6power']),
+                            ('rx7power', dom_info_dict['rx7power']),
+                            ('rx8power', dom_info_dict['rx8power']),
+                            ('tx1bias', dom_info_dict['tx1bias']),
+                            ('tx2bias', dom_info_dict['tx2bias']),
+                            ('tx3bias', dom_info_dict['tx3bias']),
+                            ('tx4bias', dom_info_dict['tx4bias']),
+                            ('tx5bias', dom_info_dict['tx5bias']),
+                            ('tx6bias', dom_info_dict['tx6bias']),
+                            ('tx7bias', dom_info_dict['tx7bias']),
+                            ('tx8bias', dom_info_dict['tx8bias']),
+                            ('tx1power', dom_info_dict['tx1power']),
+                            ('tx2power', dom_info_dict['tx2power']),
+                            ('tx3power', dom_info_dict['tx3power']),
+                            ('tx4power', dom_info_dict['tx4power']),
+                            ('tx5power', dom_info_dict['tx5power']),
+                            ('tx6power', dom_info_dict['tx6power']),
+                            ('tx7power', dom_info_dict['tx7power']),
+                            ('tx8power', dom_info_dict['tx8power'])
+                            ])
+                    
+                    # Add new key and value
+                    if 'rx_los' in dom_info_dict:
+                        fvs.append(('rx_los', dom_info_dict['rx_los']))
+                    if 'prefec_ber' in dom_info_dict:
+                        fvs.append(('prefec_ber', dom_info_dict['prefec_ber']))
+                    if 'laser_config_freq' in dom_info_dict:
+                        fvs.append(('laser_config_freq', dom_info_dict['laser_config_freq']))
+                    if 'laser_curr_freq' in dom_info_dict:
+                        fvs.append(('laser_curr_freq', dom_info_dict['laser_curr_freq']))
+                    if 'tx_config_power' in dom_info_dict:
+                        fvs.append(('tx_config_power', dom_info_dict['tx_config_power']))
+                    if 'tx_curr_power' in dom_info_dict:
+                        fvs.append(('tx_curr_power', dom_info_dict['tx_curr_power']))
+                    if 'module_state' in dom_info_dict:
+                        fvs.append(('module_state', dom_info_dict['module_state']))
+                    if 'DP1State' in dom_info_dict:
+                        fvs.append(('dp1state', dom_info_dict['DP1State']))
+                        fvs.append(('dp2state', dom_info_dict['DP2State']))
+                        fvs.append(('dp3state', dom_info_dict['DP3State']))
+                        fvs.append(('dp4state', dom_info_dict['DP4State']))
+                        fvs.append(('dp5state', dom_info_dict['DP5State']))
+                        fvs.append(('dp6state', dom_info_dict['DP6State']))
+                        fvs.append(('dp7state', dom_info_dict['DP7State']))
+                        fvs.append(('dp8state', dom_info_dict['DP8State']))
+                    if 'active_appl_code1' in dom_info_dict:
+                        fvs.append(('active_appl_code1', dom_info_dict['active_appl_code1']))
+                        fvs.append(('active_appl_code2', dom_info_dict['active_appl_code2']))
+                        fvs.append(('active_appl_code3', dom_info_dict['active_appl_code3']))
+                        fvs.append(('active_appl_code4', dom_info_dict['active_appl_code4']))
+                        fvs.append(('active_appl_code5', dom_info_dict['active_appl_code5']))
+                        fvs.append(('active_appl_code6', dom_info_dict['active_appl_code6']))
+                        fvs.append(('active_appl_code7', dom_info_dict['active_appl_code7']))
+                        fvs.append(('active_appl_code8', dom_info_dict['active_appl_code8']))
                 else:
                     fvs = swsscommon.FieldValuePairs(
                         [('temperature', dom_info_dict['temperature']),
@@ -550,7 +637,7 @@ def post_port_dom_info_to_db(logical_port_name, port_mapping, table, stop_event=
                          ('tx1power', dom_info_dict['tx1power']),
                          ('tx2power', dom_info_dict['tx2power']),
                          ('tx3power', dom_info_dict['tx3power']),
-                         ('tx4power', dom_info_dict['tx4power'])
+                         ('tx4power', dom_info_dict['tx4power']),
                          ])
 
                 table.set(port_name, fvs)
@@ -948,10 +1035,12 @@ class CmisManagerTask:
         self.namespaces = namespaces
 
     def log_notice(self, message):
-        helper_logger.log_notice("CMIS: {}".format(message))
+        # helper_logger.log_notice("CMIS: {}".format(message))
+        helper_logger.log_notice("CMIS: {}".format(message), also_print_to_console=True)
 
     def log_error(self, message):
-        helper_logger.log_error("CMIS: {}".format(message))
+        # helper_logger.log_error("CMIS: {}".format(message))
+        helper_logger.log_error("CMIS: {}".format(message), also_print_to_console=True)
 
     def on_port_update_event(self, port_change_event):
         if port_change_event.event_type not in [port_change_event.PORT_SET, port_change_event.PORT_DEL]:
@@ -995,6 +1084,8 @@ class CmisManagerTask:
                 self.port_dict[lport]['host_tx_ready'] = port_change_event.port_dict['host_tx_ready']
             if 'admin_status' in port_change_event.port_dict:
                 self.port_dict[lport]['admin_status'] = port_change_event.port_dict['admin_status']
+            if 'media_interface_code' in port_change_event.port_dict:
+                self.port_dict[lport]['media_interface_code'] = port_change_event.port_dict['media_interface_code']
             if 'laser_freq' in port_change_event.port_dict:
                 self.port_dict[lport]['laser_freq'] = int(port_change_event.port_dict['laser_freq'])
             if 'tx_power' in port_change_event.port_dict:
@@ -1034,7 +1125,20 @@ class CmisManagerTask:
             speed = 1000
         return speed
 
-    def get_cmis_application_desired(self, api, channel, speed):
+    def get_configured_media_if_from_db(self, lport):
+        """
+           Return the media interface code configured by user in CONFIG_DB's PORT table
+        """
+        media_if = None
+        asic_index = self.port_mapping.get_asic_id_for_logical_port(lport)
+        port_tbl = self.xcvr_table_helper.get_cfg_port_tbl(asic_index)
+
+        found, port_info = port_tbl.get(lport)
+        if found and 'media_interface_code' in dict(port_info):
+            media_if = dict(port_info)['media_interface_code']
+        return media_if
+
+    def get_cmis_application_desired(self, api, channel, speed, media_if):
         """
         Get the CMIS application code that matches the specified host side configurations
 
@@ -1046,6 +1150,8 @@ class CmisManagerTask:
                 e.g. 0x5 for lane 0 and lane 2.
             speed:
                 Integer, the port speed of the host interface
+            media_if:
+                String, the media interface code ID of SFF8024
 
         Returns:
             Integer, the transceiver-specific application code
@@ -1067,6 +1173,9 @@ class CmisManagerTask:
                 continue
             if self.get_interface_speed(d.get('host_electrical_interface_id')) != speed:
                 continue
+            # when media_if is None, select appl_code only by host_lane_count and speed.
+            if media_if != None and d.get('module_media_interface_id') != media_if:
+                continue
             appl_code = c
             break
 
@@ -1078,7 +1187,7 @@ class CmisManagerTask:
     def get_cmis_dp_deinit_duration_secs(self, api):
         return api.get_datapath_deinit_duration()/1000
 
-    def is_cmis_application_update_required(self, api, channel, speed):
+    def is_cmis_application_update_required(self, api, channel, speed, media_if):
         """
         Check if the CMIS application update is required
 
@@ -1097,9 +1206,7 @@ class CmisManagerTask:
         if speed == 0 or channel == 0 or api.is_flat_memory():
             return False
 
-        app_new = self.get_cmis_application_desired(api, channel, speed)
-        if app_new != 1:
-            self.log_notice("Non-default application is not supported")
+        app_new = self.get_cmis_application_desired(api, channel, speed, media_if)
 
         app_old = 0
         for lane in range(self.CMIS_NUM_CHANNELS):
@@ -1262,7 +1369,10 @@ class CmisManagerTask:
         return float(power)
 
     def get_host_tx_status(self, lport):
-        host_tx_ready = 'false'
+        # TODO: xcvrd doesn't take responsibility for the configuration of host_tx_ready.
+        # When implementing the function to configure the field,
+        # restore to the original default value.
+        host_tx_ready = 'true'
 
         asic_index = self.port_mapping.get_asic_id_for_logical_port(lport)
         state_port_tbl = self.xcvr_table_helper.get_state_port_tbl(asic_index)
@@ -1371,6 +1481,11 @@ class CmisManagerTask:
                 if pport < 0 or speed == 0 or len(lanes) < 1:
                     continue
 
+                # Always get configured media_if from CONFIG_DB,
+                # to enable user to select appl_code also when the user sets only speed and lanes.
+                self.port_dict[lport]['media_interface_code'] = self.get_configured_media_if_from_db(lport)
+                media_if = self.port_dict[lport]['media_interface_code']
+
                 # Desired port speed on the host side
                 host_speed = speed
 
@@ -1404,6 +1519,9 @@ class CmisManagerTask:
 
                     # Skip if it's not a CMIS module
                     type = api.get_module_type_abbreviation()
+                    # # Temporary input type = 'QSFP-DD'
+                    # type = 'QSFP-DD'
+                    # self.log_debug("xcvrd.CmisManagerTask.task_worker: type={}".format(type))
                     if (type is None) or (type not in self.CMIS_MODULE_TYPES):
                         self.port_dict[lport]['cmis_state'] = self.CMIS_STATE_READY
                         continue
@@ -1453,13 +1571,13 @@ class CmisManagerTask:
                               else:
                                  self.log_notice("{} Successfully configured Tx power = {}".format(lport, tx_power))
 
-                        appl = self.get_cmis_application_desired(api, host_lanes, host_speed)
+                        appl = self.get_cmis_application_desired(api, host_lanes, host_speed, media_if)
                         if appl < 1:
                             self.log_error("{}: no suitable app for the port".format(lport))
                             self.port_dict[lport]['cmis_state'] = self.CMIS_STATE_FAILED
                             continue
 
-                        need_update = self.is_cmis_application_update_required(api, host_lanes, host_speed)
+                        need_update = self.is_cmis_application_update_required(api, host_lanes, host_speed, media_if)
 
                         # For ZR module, Datapath needes to be re-initlialized on new channel selection
                         if api.is_coherent_module():
@@ -1476,6 +1594,7 @@ class CmisManagerTask:
                             continue
                         self.log_notice("{}: force Datapath reinit".format(lport))
                         self.port_dict[lport]['cmis_state'] = self.CMIS_STATE_DP_DEINIT
+
                     elif state == self.CMIS_STATE_DP_DEINIT:
                         # D.2.2 Software Deinitialization
                         api.set_datapath_deinit(host_lanes)
@@ -1516,7 +1635,7 @@ class CmisManagerTask:
                                    self.log_notice("{} configured laser frequency {} GHz".format(lport, freq))
 
                         # D.1.3 Software Configuration and Initialization
-                        appl = self.get_cmis_application_desired(api, host_lanes, host_speed)
+                        appl = self.get_cmis_application_desired(api, host_lanes, host_speed, media_if)
                         if appl < 1:
                             self.log_error("{}: no suitable app for the port".format(lport))
                             self.port_dict[lport]['cmis_state'] = self.CMIS_STATE_FAILED
@@ -1668,8 +1787,8 @@ class DomInfoUpdateTask(object):
         # To avoid race condition, remove the entry TRANSCEIVER_DOM_INFO table.
         # This thread only update TRANSCEIVER_DOM_INFO table, so we don't have to remove entries from
         # TRANSCEIVER_INFO and TRANSCEIVER_STATUS_INFO
-        del_port_sfp_dom_info_from_db(port_change_event.port_name,
-                                      self.port_mapping,
+        del_port_sfp_dom_info_from_db(port_change_event.port_name, 
+                                      self.port_mapping, 
                                       None,
                                       self.xcvr_table_helper.get_dom_tbl(port_change_event.asic_id))
 
@@ -1855,8 +1974,8 @@ class SfpStateUpdateTask(object):
                     #      this is for the vendors who don't implement "system_not_ready/system_becom_ready" logic
                     logical_port_dict = {}
                     for key, value in port_dict.items():
-                        # SFP error event should be cached because: when a logical port is created, there is no way to
-                        # detect the SFP error by platform API.
+                        # SFP error event should be cached because: when a logical port is created, there is no way to 
+                        # detect the SFP error by platform API. 
                         if value != sfp_status_helper.SFP_STATUS_INSERTED and value != sfp_status_helper.SFP_STATUS_REMOVED:
                             self.sfp_error_dict[key] = (value, error_dict)
                         else:
@@ -1993,8 +2112,8 @@ class SfpStateUpdateTask(object):
         # To avoid race condition, remove the entry TRANSCEIVER_DOM_INFO, TRANSCEIVER_STATUS_INFO and TRANSCEIVER_INFO table.
         # The operation to remove entry from TRANSCEIVER_DOM_INFO is duplicate with DomInfoUpdateTask.on_remove_logical_port,
         # but it is necessary because TRANSCEIVER_DOM_INFO is also updated in this sub process when a new SFP is inserted.
-        del_port_sfp_dom_info_from_db(port_change_event.port_name,
-                                      self.port_mapping,
+        del_port_sfp_dom_info_from_db(port_change_event.port_name, 
+                                      self.port_mapping, 
                                       self.xcvr_table_helper.get_intf_tbl(port_change_event.asic_id),
                                       self.xcvr_table_helper.get_dom_tbl(port_change_event.asic_id))
         delete_port_from_status_table(port_change_event.port_name, self.xcvr_table_helper.get_status_tbl(port_change_event.asic_id))
@@ -2014,12 +2133,12 @@ class SfpStateUpdateTask(object):
         """
         # A logical port is created. There could be 3 cases:
         #  1. SFP information is already in DB, which means that a logical port with the same physical index is in DB before.
-        #     Need copy the data from existing logical port and insert it into TRANSCEIVER_DOM_INFO, TRANSCEIVER_STATUS_INFO
+        #     Need copy the data from existing logical port and insert it into TRANSCEIVER_DOM_INFO, TRANSCEIVER_STATUS_INFO 
         #     and TRANSCEIVER_INFO table.
-        #  2. SFP information is not in DB and SFP is present with no SFP error. Need query the SFP status by platform API and
+        #  2. SFP information is not in DB and SFP is present with no SFP error. Need query the SFP status by platform API and 
         #     insert the data to DB.
-        #  3. SFP information is not in DB and SFP is present with SFP error. If the SFP error does not block EEPROM reading,
-        #     just query transceiver information and DOM sensor information via platform API and update the data to DB; otherwise,
+        #  3. SFP information is not in DB and SFP is present with SFP error. If the SFP error does not block EEPROM reading, 
+        #     just query transceiver information and DOM sensor information via platform API and update the data to DB; otherwise, 
         #     just update TRANSCEIVER_STATUS table with the error.
         #  4. SFP information is not in DB and SFP is not present. Only update TRANSCEIVER_STATUS_INFO table.
         logical_port_event_dict = {}
@@ -2029,7 +2148,7 @@ class SfpStateUpdateTask(object):
         int_tbl = self.xcvr_table_helper.get_intf_tbl(port_change_event.asic_id)
         dom_tbl = self.xcvr_table_helper.get_dom_tbl(port_change_event.asic_id)
         physical_port_list = self.port_mapping.logical_port_name_to_physical_port_list(port_change_event.port_name)
-
+        
         # Try to find a logical port with same physical index in DB
         for physical_port in physical_port_list:
             logical_port_list = self.port_mapping.get_physical_to_logical(physical_port)
@@ -2041,10 +2160,10 @@ class SfpStateUpdateTask(object):
                 if found:
                     sibling_port = logical_port
                     break
-
+            
             if sfp_status:
                 break
-
+        
         if sfp_status:
             # SFP information is in DB
             status_tbl.set(port_change_event.port_name, sfp_status)
@@ -2104,7 +2223,7 @@ class SfpStateUpdateTask(object):
         if not self.retry_eeprom_set:
             return
 
-        # Retry eeprom with an interval RETRY_EEPROM_READING_INTERVAL. No need to put sleep here
+        # Retry eeprom with an interval RETRY_EEPROM_READING_INTERVAL. No need to put sleep here 
         # because _wrapper_get_transceiver_change_event has a timeout argument.
         now = time.time()
         if now - self.last_retry_eeprom_time < self.RETRY_EEPROM_READING_INTERVAL:
@@ -2174,7 +2293,7 @@ class DaemonXcvrd(daemon_base.DaemonBase):
             (key, op, fvp) = port_tbl.pop()
             if key in ["PortConfigDone", "PortInitDone"]:
                 break
-
+            
     def load_media_settings(self):
         global g_dict
         (platform_path, _) = device_info.get_paths_to_platform_and_hwsku_dirs()
@@ -2186,7 +2305,7 @@ class DaemonXcvrd(daemon_base.DaemonBase):
 
         with open(media_settings_file_path, "r") as media_file:
             g_dict = json.load(media_file)
-
+            
     # Initialize daemon
     def init(self):
         global platform_sfputil
@@ -2205,12 +2324,13 @@ class DaemonXcvrd(daemon_base.DaemonBase):
             # in this sense, we treat it as a part of new platform api.
             # we have already moved sfputil to sonic_platform_base
             # which is the root of new platform api.
-            platform_sfputil = sonic_platform_base.sonic_sfp.sfputilhelper.SfpUtilHelper()
+            # platform_sfputil = sonic_platform_base.sonic_sfp.sfputilhelper.SfpUtilHelper()
+            # platform_sfputil = self.load_platform_util(PLATFORM_SPECIFIC_MODULE_NAME, PLATFORM_SPECIFIC_CLASS_NAME)
         except Exception as e:
             self.log_warning("Failed to load chassis due to {}".format(repr(e)))
 
         # Load platform specific sfputil class
-        if platform_chassis is None or platform_sfputil is None:
+        if platform_chassis is None:
             try:
                 platform_sfputil = self.load_platform_util(PLATFORM_SPECIFIC_MODULE_NAME, PLATFORM_SPECIFIC_CLASS_NAME)
             except Exception as e:
@@ -2233,7 +2353,8 @@ class DaemonXcvrd(daemon_base.DaemonBase):
             self.load_media_settings()
 
         warmstart = swsscommon.WarmStart()
-        warmstart.initialize("xcvrd", "pmon")
+        # warmstart.initialize("xcvrd", "pmon")
+        warmstart.initialize("xcvrd", "pmon", isTcpConn=True)
         warmstart.checkWarmStart("xcvrd", "pmon", False)
         is_warm_start = warmstart.isWarmStart()
 
@@ -2243,7 +2364,7 @@ class DaemonXcvrd(daemon_base.DaemonBase):
             self.wait_for_port_config_done(namespace)
 
         port_mapping_data = port_mapping.get_port_mapping(self.namespaces)
-
+        
         # Post all the current interface dom/sfp info to STATE_DB
         self.log_info("Post all port DOM/SFP info to DB")
         retry_eeprom_set = post_port_sfp_dom_info_to_db(is_warm_start, port_mapping_data, self.xcvr_table_helper, self.stop_event)
@@ -2340,7 +2461,7 @@ class XcvrTableHelper:
             self.app_port_tbl[asic_id] = swsscommon.ProducerStateTable(appl_db, swsscommon.APP_PORT_TABLE_NAME)
             self.cfg_db[asic_id] = daemon_base.db_connect("CONFIG_DB", namespace)
             self.cfg_port_tbl[asic_id] = swsscommon.Table(self.cfg_db[asic_id], swsscommon.CFG_PORT_TABLE_NAME)
-
+    
     def get_intf_tbl(self, asic_id):
         return self.int_tbl[asic_id]
 
